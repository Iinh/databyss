# databyss UI library

This is a component and module library for applications on the databyss platform.

## Table of Contents

* [Using Stylesheets](#using-stylesheets)
* [Post-Processing CSS](#post-processing-css)
* [Adding Images, Fonts, and Files](#adding-images-fonts-and-files)

## Using Stylesheets

This project setup uses [Webpack](https://webpack.js.org/) and [Sass](https://sass-lang.com/) for rendering styles.

Sass allows us to create shared variables and functions that we can use to keep our styles consistent and DRY.

For example, a component stylesheet might look like:

### `App/styles.scss`

```scss
@import '../../shared-styles/index';

@include mobile {
  .header {
    background-color: $dark-bg-color;
    color: $dark-txt-color;
    height: 35px;
  }
}
@include tablet {
  .header {
    height: 50px;
  }
}
```

This uses the shared colors from the `dark` theme with the sass variables `$dark-bg-color` and `$dark-txt-color`.

It also uses the sass mixins `mobile` and `tablet` to render media queries around the enclosed styles. This lets us easily define a mobile-first stylesheet and then override styles for tablet viewports and larger.

### CSS Modules

The CSS loader is configured to use [CSS Modules](https://medium.com/seek-ui-engineering/block-element-modifying-your-javascript-components-d7f99fcab52b) so that classes are locally scoped by default and we can compose classes if want.

## Post-Processing CSS

This project setup minifies your CSS and adds vendor prefixes to it automatically through [Autoprefixer](https://github.com/postcss/autoprefixer) so you don’t need to worry about it.

For example, this:

```css
.App {
  display: flex;
  flex-direction: row;
  align-items: center;
}
```

becomes this:

```css
.App {
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
  -webkit-box-align: center;
  -ms-flex-align: center;
  align-items: center;
}
```

If you need to disable autoprefixing for some reason, [follow this section](https://github.com/postcss/autoprefixer#disabling).

## Adding Images, Fonts, and Files

With Webpack, using static assets like images and fonts works similarly to CSS.

You can **`import` a file right in a JavaScript module**. This tells Webpack to include that file in the bundle. Unlike CSS imports, importing a file gives you a string value. This value is the final path you can reference in your code, e.g. as the `src` attribute of an image or the `href` of a link to a PDF.

To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a [data URI](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) instead of a path. This applies to the following file extensions: bmp, gif, jpg, jpeg, and png. SVG files are excluded due to [#1153](https://github.com/facebookincubator/create-react-app/issues/1153).

Here is an example:

```js
import React from 'react'
import logo from './logo.png' // Tell Webpack this JS file uses this image

console.log(logo) // /logo.84287d09.png

function Header() {
  // Import result is the URL of your image
  return <img src={logo} alt="Logo" />
}

export default Header
```

This ensures that when the project is built, Webpack will correctly move the images into the build folder, and provide us with correct paths.

This works in CSS too:

```css
.Logo {
  background-image: url(./logo.png);
}
```

Webpack finds all relative module references in CSS (they start with `./`) and replaces them with the final paths from the compiled bundle. If you make a typo or accidentally delete an important file, you will see a compilation error, just like when you import a non-existent JavaScript module. The final filenames in the compiled bundle are generated by Webpack from content hashes. If the file content changes in the future, Webpack will give it a different name in production so you don’t need to worry about long-term caching of assets.

Please be advised that this is also a custom feature of Webpack.

**It is not required for React** but many people enjoy it (and React Native uses a similar mechanism for images).<br>
An alternative way of handling static assets is described in the next section.
